<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <title>Jira任务管理系统</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div></div>

    <script>
      // console.time("康康");
      function debounce(fn, wait = 500) {
        var timer;
        return function (...para) {
          if (timer) {
            console.log("清除定时器");
            clearTimeout(timer);
          }

          timer = setTimeout(() => {
            // fn.apply(this, arguments);
            fn.call(null, ...para);
          }, wait);
        };
      }

      const log1 = debounce((a) => console.log(a), 1000);

      // log1(44);
      // log1(55);
      // log1(66);
      // console.timeEnd("康康");
      console.log("----------------------------------------");

      window.onerror = function (message, url, line) {
        console.log(message, url, line);
      };

      // 抛出错误一般都是与try catch 同时出现的
      // throw new Error(error); 这个是创建错误，创造一个错误类型抛出，throw error 这个是抛出错误。

      let a = 5;
      try {
        if (a == 5) {
          // 抛出错误
          throw new SyntaxError("我是被抛出的错误...");
          // Promise.reject("我是Promise抛出的错误...");
          /* Promise.reject({
                  message: "我是Promise抛出的错误...",
                }); */
        }
      } catch (error) {
        // console.log(error);
        console.log(error.message); // 我是被抛出的错误...
        console.log(error.name); // Error
      }

      try {
        if (a == 5) {
          //   抛出错误
          throw "loopTerminates";
        }
      } catch (e) {
        console.log(e); // loopTerminates
        console.log(e.message); // undefined
      }

      // 任何没有通过try-catch处理的错误都会触发window对象的error事件，触发后，之后的程序不再运行
      // throw new Error("something bad happened");
      // throw new SyntaxError("I don't like your syntax.");
      // throw new TypeError("what type of variable do you take me for?");
      // throw new RangeError("sorry,you just don't have the range.");
      // throw new EvalError("That doesn't evaluate.");
      // throw new URIError("URI, is that you?");
      // throw new ReferenceError("you didn't cite your references properly");

      // 创建自定义错误是很有用的
      /* function CustomError(message) {
              this.name = "CustomError";
              this.message = message;
            }
            CustomError.prototype = new Error();
            throw new CustomError("my message"); */

      console.log("------------------------------------");

      /* function time2() {
        for (let a = 0; a < 2000; a++) {
          console.log("time2");
        }
      }
      function time1() {
        for (let a = 0; a < 500; a++) {
          console.log("time1");
        }
        setTimeout(time2, 0);
      }
      setTimeout(time1, 0); */

      /* const logout = async () => {
        await window.localStorage.removeItem("localStorageKey");
        return 88;
      };
      console.log(logout()); // Promise {<pending>}
      logout().then((res) => console.log(res)); // 88

      // 无形参风格(point-free)  函数式编程
      const logout2 = () => {
        return Promise.resolve("哈哈哈");
      };
      function aa(a) {
        console.log(a + "--"); // 哈哈哈--
      }
      console.log(logout2()); // Promise {<fulfilled>: "哈哈哈"}
      logout2().then(aa); */

      // http://localhost:4008/test?personId=2&name=wxchat
      const searchUrl = window.location.search;
      const searchParams = new URLSearchParams(searchUrl);
      console.log(searchUrl);
      console.log(searchParams);
      for (let p of searchParams) {
        console.log(p);
      }
      console.log(searchParams.get("name"));
      console.log(searchParams.getAll("name")); // ["wxchat"]
      console.log("------------------------------------------");
      /* console.log(
        Object.fromEntries([
          ["a", 4],
          ["b", 8],
        ])
      ); // {a: 4, b: 8}
      console.log(Object.fromEntries(searchParams));  // {personId: "2", name: "wxchat"} */

      /* let entriesObj = { age: 23, name: "Jack" };
      console.log(Object.entries(entriesObj)); */

      let aa = [1, 2, 3];
      for (let v of aa) {
        console.log(v);
      }
      let aas = aa[Symbol.iterator](); // Array Iterator {}
      console.log(aas);
      console.log(aas.next()); // {value: 1, done: false}
      console.log(aas.next()); // {value: 2, done: false}
      console.log(aas.next()); // {value: 3, done: false}
      console.log(aas.next()); // {value: undefined, done: true}

      console.log("------------------------------------------");
      const objIterator = {
        data: ["hello", "world"],
        [Symbol.iterator]() {
          const self = this;
          let index = 0;

          return {
            next() {
              if (index < self.data.length) {
                return {
                  value: self.data[index++] + "!",
                  done: false,
                };
              } else {
                return { value: undefined, done: true };
              }
            },
          };
        },
      };

      for (let o of objIterator) {
        console.log(o);
      }
      /* const objIterator2 = { a: 1 };
      for (let o of objIterator2) {
        console.log(o); // Uncaught TypeError: objIterator2 is not iterable
      } */
    </script>
  </body>
</html>
